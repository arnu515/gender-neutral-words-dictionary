<script lang="ts">
import { onDestroy, onMount } from 'svelte'
import { useNavigate, Link } from 'svelte-navigator'
import { Query, RealtimeResponseEvent } from 'appwrite'
import appwrite from '$lib/appwrite'
import user from '$lib/user.store'
import Word from '$components/Word.svelte'

const goto = useNavigate()
const q = (new URLSearchParams(window.location.search).get('q') || '').trim()
let wordsLoading = true
let voteLoading = false

interface Word {
	$id: string
	word: string
	words: string[]
	userId: string
	points: number
	userHasVoted: 'no' | 'positive' | 'negative'
}

let words: Word[] = []
let unsub: () => void = () => {}

onMount(async () => {
	if (!q) goto('/')

	const res = await appwrite.database.listDocuments('words', [Query.search('words', q)])
	words = await Promise.all(
		res.documents.map(async (i: any) => {
			console.log(i)
			let points = 0
			let userHasVoted: Word['userHasVoted'] = 'no'
			try {
				const votes = await appwrite.database.listDocuments('votes', [
					Query.equal('wordId', i.$id)
				])
				console.log(votes)
				for (const vote of votes.documents as any) {
					console.log(vote)
					if (vote.type === 'negative') points -= 1
					if (vote.type === 'positive') points += 1
					if (vote.userId === $user?.$id) userHasVoted = vote.type
				}
			} catch {}
			return {
				$id: i.$id,
				userId: i.userId,
				word: i.word,
				words: i.words,
				points,
				userHasVoted
			}
		})
	)

	wordsLoading = false

	unsub = appwrite.subscribe('collections.votes.documents', listenVote)
})

onDestroy(() => unsub)

async function onReport(id: string, message: string) {
	await appwrite.database.createDocument('reports', 'unique()', {
		wordId: id,
		message
	})
	alert('Reported successfully.')
}

async function onVote(id: string, type: Word['userHasVoted']) {
	if (voteLoading) return
	if (!$user) {
		goto('/auth')
		return
	}
	voteLoading = true
	await appwrite.functions.createExecution(
		'vote',
		JSON.stringify({
			wordId: id,
			vote: type
		}),
		false
	)
	words = words.map(i => {
		if (i.$id === id) {
			let points = i.points
			if (type === 'positive') points += i.userHasVoted === 'negative' ? 2 : 1
			if (type === 'negative') points -= i.userHasVoted === 'positive' ? 2 : 1
			if (type === 'no') points -= i.userHasVoted === 'positive' ? 1 : -1
			return { ...i, userHasVoted: type, points }
		} else return i
	})
	voteLoading = false
}

async function listenVote(
	e: RealtimeResponseEvent<{
		$id: string
		$read: string[]
		$write: string[]
		type: 'positive' | 'negative' | 'no'
		userId: string
		wordId: string
	}>
) {
	// ignore events generated by the user
	if (e.payload.userId === $user?.$id) return
	const word = words.find(i => i.$id === e.payload.wordId)
	if (e.event.includes('delete')) {
		if (e.payload.type === 'negative') word.points++
		if (e.payload.type === 'positive') word.points--
	} else if (e.event.includes('create')) {
		if (e.payload.type === 'negative') word.points--
		if (e.payload.type === 'positive') word.points++
	}
	words = words.map(i => (i.$id === e.payload.wordId ? word : i))
}
</script>

<h1
	class="m-4 text-center text-2xl font-bold sm:my-6 sm:text-3xl md:my-8 md:text-4xl lg:my-12 lg:text-5xl"
>
	Words for: {q}
</h1>
{#if wordsLoading}
	<p class="mt-8 text-center text-lg text-gray-500">Loading...</p>
{:else if words.length}
	{#each words as word}
		<Word
			points={word.points}
			userHasVoted={word.userHasVoted}
			word={word.word}
			words={word.words}
			on:report={e => onReport(word.$id, e.detail)}
			on:vote={e => onVote(word.$id, e.detail)}
		/>
	{/each}
{:else}
	<p class="mt-8 text-center text-lg text-gray-500 mx-4">
		No words found for {q}. Try using an alternate spelling, or
		<Link to="/new" class="a">contribute your own</Link>.
	</p>
{/if}
